"""Plutôt que coder à chaque fois un modèle en C on veut créer un outil qui va récupérer un modèle entraîné via scikit-learn et générer le Code C d'inférence. 

L'objectif des exercices qui suivent est de faire une librairie python qui chargera un modèle scikit-lean entraîné et génèrera le code d'inférence dudit modèle sans dépendance externe."""


"""1. Coder un script python transpile_simple_model.py qui :

- charge un fichier joblib contenant une régression linéaire entraînée

- récupère les valeurs de coefficients 

- génère une chaîne de caractère contenant le code C permettant de calculer la prédiction du modèle (float prediction(float *features, int n_feature) )avec les valeur du coefficient

- génère une fonction main qui permet d'appeler prediction sur une donnée définié par un tableau statique de votre choix. 

- sauvegarde le code c généré dans un fichier.c 

- et affiche la commande de compilation à lancer pour le compiler ou le compile directement.

 

2. Entraîner une régression linéaire simple sur un dataset simple (par exemple houses.csv) et le sauvegarder

 

3. Lancer le script transpile_simple_model et compiler le fichier C générer. Vérifier que les prédictions produites par votre code  sont conformes au model.predict

 

Script d'entraînement d'une régression linéaire : https://drive.google.com/drive/folders/1BJxzU9N_GQkv6gtpDTOjlJm3v6bjUKnX?usp=share_link"""


import argparse
import os
import subprocess
from joblib import load

##### Code C Régression Linéaire #######
def generate_c_code(coefs, intercept, static_features):
    n = len(coefs)

    # Génération C (C99)
    lines = []
    lines.append("#include <stdio.h>")
    lines.append("")
    lines.append("float prediction(float *features, int n_feature) {")
    lines.append(f"    const int expected = {n};")
    lines.append("    if (n_feature != expected) {")
    lines.append("        // En TP: on renvoie 0 si la taille ne match pas")
    lines.append("        return 0.0f;")
    lines.append("    }")
    lines.append(f"    float y = {float(intercept):.9f}f;")

    # Forme simple: somme coef[i] * features[i]
    for i, c in enumerate(coefs):
        lines.append(f"    y += {float(c):.9f}f * features[{i}];")

    lines.append("    return y;")
    lines.append("}")
    lines.append("")
    lines.append("int main(void) {")
    lines.append(f"    float x[{n}] = {{ " + ", ".join(f"{float(v):.6f}f" for v in static_features) + " };")
    lines.append(f"    float y = prediction(x, {n});")
    lines.append('    printf("prediction=%.6f\\n", y);')
    lines.append("    return 0;")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)

#######

##### Code Arduino #######

def generate_arduino_code(coefs, intercept, n_features):
    lines = []
    lines.append("// Auto-generated by transpiler")
    lines.append("#include <Arduino.h>")
    lines.append("")
    lines.append("static float prediction(float *features, int n_feature) {")
    lines.append(f"  const int expected = {n_features};")
    lines.append("  if (n_feature != expected) return 0.0f;")
    lines.append(f"  float y = {float(intercept):.9f}f;")
    for i, c in enumerate(coefs):
        lines.append(f"  y += {float(c):.9f}f * features[{i}];")
    lines.append("  return y;")
    lines.append("}")
    lines.append("")
    lines.append("// Parse une ligne CSV \"v1,v2,...\" dans features[]")
    lines.append("static bool parse_csv_line(const char *line, float *features, int expected) {")
    lines.append("  int idx = 0;")
    lines.append("  const char *p = line;")
    lines.append("  char *endptr = nullptr;")
    lines.append("  while (idx < expected) {")
    lines.append("    float v = strtof(p, &endptr);")
    lines.append("    if (endptr == p) return false; // pas de nombre lu")
    lines.append("    features[idx++] = v;")
    lines.append("    p = endptr;")
    lines.append("    while (*p == ' ' || *p == '\\t') p++;")
    lines.append("    if (idx < expected) {")
    lines.append("      if (*p == ',') { p++; }")
    lines.append("      else return false; // séparateur attendu")
    lines.append("    }")
    lines.append("    while (*p == ' ' || *p == '\\t') p++;")
    lines.append("  }")
    lines.append("  return true;")
    lines.append("}")
    lines.append("")
    lines.append(f"static float features[{n_features}];")
    lines.append("static String bufferLine;")
    lines.append("")
    lines.append("void setup() {")
    lines.append("  Serial.begin(115200);")
    lines.append("  while (!Serial) { delay(10); }")
    lines.append("  Serial.println(\"READY\");")
    lines.append("  Serial.println(\"Send CSV features like: 1.0,2.0,3.0\");")
    lines.append("}")
    lines.append("")
    lines.append("void loop() {")
    lines.append("  while (Serial.available() > 0) {")
    lines.append("    char c = (char)Serial.read();")
    lines.append("    if (c == '\\n' || c == '\\r') {")
    lines.append("      if (bufferLine.length() == 0) continue;")
    lines.append("      // Copie vers buffer C")
    lines.append("      char line[256];")
    lines.append("      bufferLine.trim();")
    lines.append("      bufferLine.toCharArray(line, sizeof(line));")
    lines.append("")
    lines.append(f"      const int expected = {n_features};")
    lines.append("      bool ok = parse_csv_line(line, features, expected);")
    lines.append("      if (!ok) {")
    lines.append("        Serial.println(\"ERR: parse\");")
    lines.append("      } else {")
    lines.append("        float y = prediction(features, expected);")
    lines.append("        Serial.print(\"pred=\");")
    lines.append("        Serial.println(y, 6);")
    lines.append("      }")
    lines.append("      bufferLine = \"\";")
    lines.append("    } else {")
    lines.append("      bufferLine += c;")
    lines.append("      if (bufferLine.length() > 240) {")
    lines.append("        bufferLine = \"\";")
    lines.append("        Serial.println(\"ERR: line too long\");")
    lines.append("      }")
    lines.append("    }")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)

#############################

# Code Logistic Regression

#############################

def generate_logreg_c_code(coefs, intercept, static_features, threshold=0.5):
    n = len(coefs)

    lines = []
    lines.append("#include <stdio.h>")
    lines.append("#include <math.h>")  # expf
    lines.append("")
    lines.append("static float sigmoidf(float z) {")
    lines.append("    // version stable pour éviter overflow exp")
    lines.append("    if (z >= 0.0f) {")
    lines.append("        float e = expf(-z);")
    lines.append("        return 1.0f / (1.0f + e);")
    lines.append("    } else {")
    lines.append("        float e = expf(z);")
    lines.append("        return e / (1.0f + e);")
    lines.append("    }")
    lines.append("}")
    lines.append("")
    lines.append("float predict_proba(float *features, int n_feature) {")
    lines.append(f"    const int expected = {n};")
    lines.append("    if (n_feature != expected) return 0.0f;")
    lines.append(f"    float z = {float(intercept):.9f}f;")
    for i, c in enumerate(coefs):
        lines.append(f"    z += {float(c):.9f}f * features[{i}];")
    lines.append("    return sigmoidf(z);")
    lines.append("}")
    lines.append("")
    lines.append("int predict_class(float *features, int n_feature) {")
    lines.append(f"    float p = predict_proba(features, n_feature);")
    lines.append(f"    return (p >= {float(threshold):.6f}f) ? 1 : 0;")
    lines.append("}")
    lines.append("")
    lines.append("int main(void) {")
    lines.append(f"    float x[{n}] = {{ " + ", ".join(f"{float(v):.6f}f" for v in static_features) + " };")
    lines.append(f"    float p = predict_proba(x, {n});")
    lines.append(f"    int   y = predict_class(x, {n});")
    lines.append('    printf("proba=%.6f\\n", p);')
    lines.append('    printf("class=%d\\n", y);')
    lines.append("    return 0;")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)


##### Code Arduino Logistic Regression #######
def generate_logreg_arduino_code(coefs, intercept, n_features, threshold=0.5):
    lines = []
    lines.append("// Auto-generated by transpiler (Logistic Regression)")
    lines.append("#include <Arduino.h>")
    lines.append("#include <math.h>")
    lines.append("")
    lines.append("static float sigmoidf(float z) {")
    lines.append("  if (z >= 0.0f) {")
    lines.append("    float e = expf(-z);")
    lines.append("    return 1.0f / (1.0f + e);")
    lines.append("  } else {")
    lines.append("    float e = expf(z);")
    lines.append("    return e / (1.0f + e);")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    lines.append("static float predict_proba(float *features, int n_feature) {")
    lines.append(f"  const int expected = {n_features};")
    lines.append("  if (n_feature != expected) return 0.0f;")
    lines.append(f"  float z = {float(intercept):.9f}f;")
    for i, c in enumerate(coefs):
        lines.append(f"  z += {float(c):.9f}f * features[{i}];")
    lines.append("  return sigmoidf(z);")
    lines.append("}")
    lines.append("")
    lines.append("static int predict_class(float *features, int n_feature) {")
    lines.append(f"  float p = predict_proba(features, n_feature);")
    lines.append(f"  return (p >= {float(threshold):.6f}f) ? 1 : 0;")
    lines.append("}")
    lines.append("")
    # Tu peux réutiliser TON parse_csv_line tel quel :
    lines.append("// Parse une ligne CSV \"v1,v2,...\" dans features[]")
    lines.append("static bool parse_csv_line(const char *line, float *features, int expected) {")
    lines.append("  int idx = 0;")
    lines.append("  const char *p = line;")
    lines.append("  char *endptr = nullptr;")
    lines.append("  while (idx < expected) {")
    lines.append("    float v = strtof(p, &endptr);")
    lines.append("    if (endptr == p) return false;")
    lines.append("    features[idx++] = v;")
    lines.append("    p = endptr;")
    lines.append("    while (*p == ' ' || *p == '\\t') p++;")
    lines.append("    if (idx < expected) {")
    lines.append("      if (*p == ',') p++; else return false;")
    lines.append("    }")
    lines.append("    while (*p == ' ' || *p == '\\t') p++;")
    lines.append("  }")
    lines.append("  return true;")
    lines.append("}")
    lines.append("")
    lines.append(f"static float features[{n_features}];")
    lines.append("static String bufferLine;")
    lines.append("")
    lines.append("void setup() {")
    lines.append("  Serial.begin(115200);")
    lines.append("  while (!Serial) { delay(10); }")
    lines.append("  Serial.println(\"READY_LOGREG\");")
    lines.append("  Serial.println(\"Send CSV features like: 1.0,2.0,3.0\");")
    lines.append("}")
    lines.append("")
    lines.append("void loop() {")
    lines.append("  while (Serial.available() > 0) {")
    lines.append("    char c = (char)Serial.read();")
    lines.append("    if (c == '\\n' || c == '\\r') {")
    lines.append("      if (bufferLine.length() == 0) continue;")
    lines.append("      char line[256];")
    lines.append("      bufferLine.trim();")
    lines.append("      bufferLine.toCharArray(line, sizeof(line));")
    lines.append("")
    lines.append(f"      const int expected = {n_features};")
    lines.append("      bool ok = parse_csv_line(line, features, expected);")
    lines.append("      if (!ok) {")
    lines.append("        Serial.println(\"ERR: parse\");")
    lines.append("      } else {")
    lines.append("        float p = predict_proba(features, expected);")
    lines.append("        int y = predict_class(features, expected);")
    lines.append("        Serial.print(\"proba=\"); Serial.println(p, 6);")
    lines.append("        Serial.print(\"class=\"); Serial.println(y);")
    lines.append("      }")
    lines.append("      bufferLine = \"\";")
    lines.append("    } else {")
    lines.append("      bufferLine += c;")
    lines.append("      if (bufferLine.length() > 240) {")
    lines.append("        bufferLine = \"\";")
    lines.append("        Serial.println(\"ERR: line too long\");")
    lines.append("      }")
    lines.append("    }")
    lines.append("  }")
    lines.append("}")
    lines.append("")
    return "\n".join(lines)

#######


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--model", required=True, help="Chemin vers le modèle .joblib (LinearRegression / LogisticRegression)")
    parser.add_argument("--out", default="generated_model.c", help="Nom du fichier généré (.c ou .ino)")
    parser.add_argument("--compile", action="store_true", help="Compile le C via gcc (mode .c uniquement)")
    parser.add_argument("--run", action="store_true", help="Exécute le binaire après compilation (mode .c uniquement)")
    parser.add_argument("--arduino", action="store_true", help="Génère un sketch Arduino .ino au lieu d'un .c")
    args = parser.parse_args()

    model = load(args.model)
    model_name = model.__class__.__name__

    # -------------------------
    # 1) Linear Regression
    # -------------------------
    if model_name == "LinearRegression":
        if not hasattr(model, "coef_") or not hasattr(model, "intercept_"):
            raise TypeError("Le modèle LinearRegression chargé n'a pas coef_ / intercept_.")

        coefs = list(model.coef_)
        intercept = float(model.intercept_)
        n_features = len(coefs)

        if args.arduino:
            if not args.out.endswith(".ino"):
                args.out = os.path.splitext(args.out)[0] + ".ino"
            code = generate_arduino_code(coefs, intercept, n_features)

            with open(args.out, "w", encoding="utf-8") as f:
                f.write(code)

            print(f"[OK] Sketch Arduino (linreg) généré: {args.out}")
            print("[INFO] Ouvre-le dans l'IDE Arduino, flash, puis teste au Moniteur Série (115200).")
            if args.compile or args.run:
                print("[WARN] --compile/--run ignorés en mode Arduino.")
            return

        # Mode C
        if not args.out.endswith(".c"):
            args.out = os.path.splitext(args.out)[0] + ".c"

        static_features = [float(i + 1) for i in range(n_features)]
        code = generate_c_code(coefs, intercept, static_features)

        with open(args.out, "w", encoding="utf-8") as f:
            f.write(code)

        exe = os.path.splitext(args.out)[0]
        compile_cmd = f"gcc -O2 -std=c99 {args.out} -o {exe}"

        print(f"[OK] Fichier C (linreg) généré: {args.out}")
        print(f"[INFO] Commande de compilation :\n{compile_cmd}")

        if args.compile:
            print("[INFO] Compilation...")
            subprocess.check_call(compile_cmd, shell=True)
            print(f"[OK] Binaire créé: {exe}")

            if args.run:
                print("[INFO] Exécution...")
                subprocess.check_call(f"./{exe}", shell=True)

        return

    # -------------------------
    # 2) Logistic Regression (binaire)
    # -------------------------
    if model_name == "LogisticRegression":
        if not hasattr(model, "coef_") or not hasattr(model, "intercept_"):
            raise TypeError("Le modèle LogisticRegression chargé n'a pas coef_ / intercept_.")

        # Cas binaire attendu: coef_.shape = (1, n_features)
        if len(model.coef_.shape) != 2 or model.coef_.shape[0] != 1:
            raise ValueError(
                f"LogisticRegression multi-classe détectée (coef_.shape={model.coef_.shape}). "
                "Ce main gère le cas binaire uniquement."
            )

        coefs = list(model.coef_[0])
        intercept = float(model.intercept_[0])
        n_features = len(coefs)

        if args.arduino:
            if not args.out.endswith(".ino"):
                args.out = os.path.splitext(args.out)[0] + ".ino"
            code = generate_logreg_arduino_code(coefs, intercept, n_features, threshold=0.5)

            with open(args.out, "w", encoding="utf-8") as f:
                f.write(code)

            print(f"[OK] Sketch Arduino (logreg) généré: {args.out}")
            print("[INFO] Ouvre-le dans l'IDE Arduino, flash, puis teste au Moniteur Série (115200).")
            print("[INFO] Envoie: v1,v2,...,vn  -> Arduino répond: proba=... puis class=...")
            if args.compile or args.run:
                print("[WARN] --compile/--run ignorés en mode Arduino.")
            return

        # Mode C
        if not args.out.endswith(".c"):
            args.out = os.path.splitext(args.out)[0] + ".c"

        static_features = [float(i + 1) for i in range(n_features)]
        code = generate_logreg_c_code(coefs, intercept, static_features, threshold=0.5)

        with open(args.out, "w", encoding="utf-8") as f:
            f.write(code)

        exe = os.path.splitext(args.out)[0]
        # NOTE: -lm nécessaire pour expf
        compile_cmd = f"gcc -O2 -std=c99 {args.out} -lm -o {exe}"

        print(f"[OK] Fichier C (logreg) généré: {args.out}")
        print(f"[INFO] Commande de compilation :\n{compile_cmd}")

        if args.compile:
            print("[INFO] Compilation...")
            subprocess.check_call(compile_cmd, shell=True)
            print(f"[OK] Binaire créé: {exe}")

            if args.run:
                print("[INFO] Exécution...")
                subprocess.check_call(f"./{exe}", shell=True)

        return

    # -------------------------
    # 3) Autres modèles
    # -------------------------
    raise TypeError(f"Modèle non supporté: {model_name} (seuls LinearRegression / LogisticRegression sont gérés)")




if __name__ == "__main__":
    main()

    